//	Библиотека для работы с датчиком пульса. http://iarduino.ru/shop/Sensory-Datchiki/datchik-pulsa.html
//  Версия: 1.0.1
//  Последнюю версию библиотеки Вы можете скачать по ссылке: http://iarduino.ru/file/261.html
//  Подробное описание функции бибилиотеки доступно по ссылке: http://lesson.iarduino.ru/page/urok-27-pulsometr/
//  Библиотека является собственностью интернет магазина iarduino.ru и может свободно использоваться и распространяться!
//  При публикации устройств или скетчей с использованием данной библиотеки, как целиком, так и её частей,
//  в том числе и в некоммерческих целях, просим Вас опубликовать ссылку: http://iarduino.ru
//  Автор библиотеки: Панькин Павел sajaem@narod.ru
//  Если у Вас возникли технические вопросы, напишите нам: shop@iarduino.ru

#ifndef iarduino_SensorPulse_h
#define iarduino_SensorPulse_h

#if defined(ARDUINO) && (ARDUINO >= 100)
#include <Arduino.h>
#else
#include <WProgram.h>
#endif

#if defined(__AVR_ATmega32U4__)									//	Если используется плата на базе микроконтроллера ATmega32U4 (Arduino Micro или Arduino Leonardo), то ...
#if !defined(TCCR2A)											//	Если Arduino IDE не знает, что у этих микроконтроллеров есть второй аппаратный таймер, то ...
	#define TCCR2A					(*(uint8_t*)0xB0)			//	Определяем смещение для регистра TCCR2A - регистр выбора режима
	#define COM2A1					7							//	Определяем позицию  в регистре   TCCR2A для старшего бита выбора режима сравнения канала А
	#define COM2A0					6							//	Определяем позицию  в регистре   TCCR2A для младшего бита выбора режима сравнения канала А
	#define COM2B1					5							//	Определяем позицию  в регистре   TCCR2A для старшего бита выбора режима сравнения канала B
	#define COM2B0					4							//	Определяем позицию  в регистре   TCCR2A для младшего бита выбора режима сравнения канала B
	#define WGM21					1							//	Определяем позицию  в регистре   TCCR2A для 1 бита выбора режима работы таймера
	#define WGM20					0							//	Определяем позицию  в регистре   TCCR2A для 0 бита выбора режима работы таймера
	#define TCCR2B					(*(uint8_t*)0xB1)			//	Определяем смещение для регистра TCCR2B - рагистр делителя
	#define FOC2A					7							//	Определяем позицию  в регистре   TCCR2B для бита принудительной установки результата сравнения канала A
	#define FOC2B					6							//	Определяем позицию  в регистре   TCCR2B для бита принудительной установки результата сравнения канала B
	#define WGM22					3							//	Определяем позицию  в регистре   TCCR2B для 2 бита выбора режима работы таймера
	#define CS22					2							//	Определяем позицию  в регистре   TCCR2B для старшего бита выбора источника тактового сигнала таймера
	#define CS21					1							//	Определяем позицию  в регистре   TCCR2B для среднего бита выбора источника тактового сигнала таймера
	#define CS20					0							//	Определяем позицию  в регистре   TCCR2B для младшего бита выбора источника тактового сигнала таймера
	#define TCNT2					(*(uint8_t*)0xB2)			//	Определяем смещение для регистра TCNT2  - счётный регистр
	#define OCR2A					(*(uint8_t*)0xB3)			//	Определяем смещение для регистра OCR2A  - регистр сравнения канала A
	#define OCR2B					(*(uint8_t*)0xB4)			//	Определяем смещение для регистра OCR2B  - регистр сравнения канала B
	#define TIFR2					(*(uint8_t*)0x37)			//	Определяем смещение для регистра TIFR2  - регистр флагов
	#define OCF2B					2							//	Определяем позицию  в регистре   TIFR2  для флага совпадения значения счетного регистра TCNT2 с регистром сравнения OCR2A
	#define OCF2A					1							//	Определяем позицию  в регистре   TIFR2  для флага совпадения значения счетного регистра TCNT2 с регистром сравнения OCR2B
	#define TOV2					0							//	Определяем позицию  в регистре   TIFR2  для флага переполнения счетного регистра TCNT2
	#define TIMSK2					(*(uint8_t*)0x70)			//	Определяем смещение для регистра TIMSK2 - регистр разрешения прерываний
	#define OCIE2B					2							//	Определяем позицию  в регистре   TIMSK2 для бита разрешения прерываний по установке флага OCF2B
	#define OCIE2A					1							//	Определяем позицию  в регистре   TIMSK2 для бита разрешения прерываний по установке флага OCF2A
	#define TOIE2					0							//	Определяем позицию  в регистре   TIMSK2 для бита разрешения прерываний по установке флага TOF2
	#define TIMER2_COMPA_vect_num	13							//	Определяем номер  вектора  для  события установки флага OCF2A
	#define TIMER2_COMPA_vect		_VECTOR(13)					//	Определяем вектор прерываний по событию установки флага OCF2A
	#define TIMER2_COMPB_vect_num	14							//	Определяем номер  вектора  для  события установки флага OCF2B
	#define TIMER2_COMPB_vect		_VECTOR(14)					//	Определяем вектор прерываний по событию установки флага OCF2B
	#define TIMER2_OVF_vect_num		15							//	Определяем номер  вектора  для  события установки флага TOV2
	#define TIMER2_OVF_vect			_VECTOR(15)					//	Определяем вектор прерываний по событию установки флага TOV2
#endif															//
#endif															//

#define	ISP_ANALOG					0							//	если эту константу указать в качестве аргумента функции check, то последняя вернёт - текущее значение с аналогового входа к которому подключён сенсор
#define	ISP_BEEP					1							//	если эту константу указать в качестве аргумента функции check, то последняя вернёт - десятые доли секунды прошедшие с последнего пульса
#define	ISP_PULSE					2							//	если эту константу указать в качестве аргумента функции check, то последняя вернёт - среднее значение пульса (количество ударов в минуту)
#define	ISP_VALID					3							//	если эту константу указать в качестве аргумента функции check, то последняя вернёт - состояние сенсора

#define	ISP_DISCONNECTED			0							//	состояние сенсора - отключён
#define	ISP_CONNECTED				1							//	состояние сенсора - подключён
#define	ISP_CHANGED					2							//	состояние сенсора - изменилось

class iarduino_SensorPulse{
	public:			iarduino_SensorPulse(uint8_t, uint8_t=255);	//	указываем номер аналогового входа к которому подключён сенсор
	/**	пользовательские функции **/
		void		begin				();						//	инициализация счётчика пульса	(без параметров)
		uint16_t	check				(uint8_t);				//	проверка результата				(что проверять)
	private:
	/**	внутренние функции **/
		void		ISP_func_SET_Timer2	(uint32_t);				//	установка таймера2				(частота прерываний в Гц)
		uint16_t	ISP_func_CheckBeep	();						//	проверка времени прошедшего после вершины пульса
		uint16_t	ISP_func_CheckPulse	();						//	проверка значения пульса
		uint8_t		ISP_func_CheckValid	();						//	проверка валидности результата
	/**	внутренние переменные **/
};

class iarduino_SensorPulse_VolatileVariableClass{
	public:
	/**	переменные изменяемые в прерываниях **/
		volatile	bool			ISP_flag_VAL=0;				//	флаг указывающий о том, что показания сенсора валидны
		volatile	uint8_t			ISP_pins_SEN=255;			//	номер аналогового входа, к которому подключён сенсор пульса
		volatile	uint8_t			ISP_pins_BEP=255;			//	номер цифрового  вывода, к которому подключён биппер
		volatile	bool			ISP_data_BEP=0;				//	состояние на выводе, к которому подключён биппер
		volatile	bool			ISP_flag_BEP=0;				//	флаг указывающий о том, что биппер подключён
		volatile	uint16_t		ISP_data_PIN[10];			//	10 последних значений, прочитанных с аналогового входа, к которому подключён сенсор пульса
		volatile	uint16_t		ISP_data_MAX=0;				//  максимальное значение сенсора за текущие 2 секунды
		volatile	uint16_t		ISP_data_MIN=1024;			//  минимальное  значение сенсора за текущие 2 секунды
		volatile	uint16_t		ISP_data_CEN=0;				//  2/3 части от минимального до максимального значения за предыдущие 2 секунды
		volatile	uint16_t		ISP_time_CNT=0;				//	счетчик прерываний 2 таймера
		volatile	uint8_t			ISP_data_TOP=0;				//	количество точек графика находящихся возле вершины пульса
		volatile	bool			ISP_flag_TOP=0;				//	флаг указывающий о том, что более 7 точек графика находятся возле вершины пульса
		volatile	uint16_t		ISP_time_TOP=0;				//	время прошедшее после того, как более 7 точек графика вошли в вершину пульса (в мс/4)
		volatile	uint16_t		ISP_time_ARR[5]={0,0,0,0,0};//	промежутки времени между 6 последними пульсами
		volatile	unsigned long	ISP_time_NOW;				//	время фиксации последнего     пульса
		volatile	unsigned long	ISP_time_WAS;				//	время фиксации предпоследнего пульса
};

#endif